generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id           String        @id
  email        String        @unique
  name         String?
  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt
  sourcingJobs SourcingJob[]
  jobs         Job[]
  userCredits  UserCredits?
  subscription Subscription?

  @@map("users")
}

model Job {
  id                 String          @id @default(uuid())
  userId             String
  title              String
  description        String?
  jdFileUrl          String?
  requiredSkills     String[]
  experienceRequired String?
  qualifications     String[]
  status             String          @default("draft")
  totalCandidates    Int             @default(0)
  createdAt          DateTime        @default(now())
  updatedAt          DateTime        @updatedAt
  candidates         Candidate[]
  user               User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  processingLogs     ProcessingLog[]

  @@index([userId])
  @@map("jobs")
}

model Candidate {
  id                   String   @id @default(uuid())
  jobId                String
  name                 String
  email                String?
  phone                String?
  resumeUrl            String
  resumeText           String?
  skills               String[]
  experience           Json?
  education            Json?
  totalExperienceYears Int?
  matchScore           Int?
  matchedSkills        String[]
  missingSkills        String[]
  fitVerdict           String?
  summary              String?
  strengths            String[]
  weaknesses           String[]
  processingStatus     String   @default("pending")
  processingError      String?
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  resumePath           String
  job                  Job      @relation(fields: [jobId], references: [id], onDelete: Cascade)

  @@index([jobId])
  @@index([matchScore])
  @@map("candidates")
}

model ProcessingLog {
  id               String    @id @default(uuid())
  jobId            String
  status           String
  totalResumes     Int?
  processedResumes Int       @default(0)
  failedResumes    Int       @default(0)
  errorMessage     String?
  startedAt        DateTime  @default(now())
  completedAt      DateTime?
  job              Job       @relation(fields: [jobId], references: [id], onDelete: Cascade)

  @@map("processing_logs")
}

model SourcingJob {
  id                  String              @id @default(cuid())
  userId              String
  title               String
  rawJobDescription   String
  maxCandidates       Int                 @default(50)
  searchFilters       Json?
  discoveredUrls      Json?
  status              SourcingJobStatus   @default(CREATED)
  totalProfilesFound  Int                 @default(0)
  profilesScraped     Int                 @default(0)
  profilesScored      Int                 @default(0)
  processingStartedAt DateTime?
  lastActivityAt      DateTime?
  errorMessage        String?
  retryCount          Int                 @default(0)
  failedAt            DateTime?
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt
  completedAt         DateTime?
  scrapedProfilesData Json?
  parsedProfilesData  Json?
  currentStage        String?
  profilesParsed      Int                 @default(0)
  profilesSaved       Int                 @default(0)
  rateLimitHitAt      DateTime?
  rateLimitResetAt    DateTime?
  maxRetries          Int                 @default(3)
  jobRequirements     Json?
  lastCompletedStage  String?
  enrichedUrls        Json?
  rateLimitService    String?
  usedQueryIndices    Json?
  candidates          LinkedInCandidate[]
  user                User                @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, status])
  @@index([lastActivityAt])
  @@index([status, lastActivityAt])
}

model LinkedInCandidate {
  id                        String                    @id @default(cuid())
  sourcingJobId             String
  fullName                  String
  headline                  String?
  location                  String?
  profileUrl                String
  photoUrl                  String?
  currentPosition           String?
  currentCompany            String?
  experienceYears           Int?
  skills                    Json?
  experience                Json?
  education                 Json?
  email                     String?
  phone                     String?
  hasContactInfo            Boolean                   @default(false)
  matchScore                Float                     @default(0)
  skillsScore               Float                     @default(0)
  experienceScore           Float                     @default(0)
  industryScore             Float                     @default(0)
  titleScore                Float                     @default(0)
  matchReason               String?
  isScored                  Boolean                   @default(false)
  isDuplicate               Boolean                   @default(false)
  firstSeenJobId            String?
  batchNumber               Int                       @default(0)
  rawData                   Json?
  scrapedAt                 DateTime?
  scoredAt                  DateTime?
  bonusSkills               Json?
  certifications            Json?
  connections               Int?
  currentCompanyLogo        String?
  currentJobDuration        String?
  duplicateCount            Int                       @default(0)
  followers                 Int?
  industryMatch             String?
  isOpenToWork              Boolean                   @default(false)
  isPremium                 Boolean                   @default(false)
  isVerified                Boolean                   @default(false)
  languages                 Json?
  linkedInId                String?
  matchedSkills             Json?
  missingSkills             Json?
  niceToHaveScore           Float                     @default(0)
  publicIdentifier          String?
  relevantYears             Int?
  scoringVersion            String?
  seniorityLevel            String?
  updatedAt                 DateTime                  @updatedAt
  aiAnalysisVersion         String?                   @default("v3.0")
  analysisGeneratedAt       DateTime?
  candidateSummary          String?
  criticalGaps              Json?
  experienceAnalysisSummary String?
  experienceHighlights      Json?
  experienceRelevanceScore  Float?                    @default(0)
  fullAnalysisGenerated     Boolean                   @default(false)
  gapsAndTradeoffs          Json?
  gapsOverallImpact         String?
  gapsSummary               String?
  hasSignificantGaps        Boolean                   @default(false)
  industryAlignment         String?
  interviewConfidenceScore  Float?                    @default(0)
  interviewFocusAreas       Json?
  interviewFocusSummary     String?
  interviewReadiness        InterviewReadinessStatus  @default(NOT_ASSESSED)
  interviewReadinessReason  String?
  keyStrengths              Json?
  redFlags                  Json?
  seniorityAlignment        String?
  skillGapImpact            String?
  skillsAnalysisSummary     String?
  skillsProficiency         Json?
  suggestedQuestions        Json?
  emailSource               String?
  enrichedAt                DateTime?
  enrichmentStatus          CandidateEnrichmentStatus @default(PENDING)
  scrapingStatus            String?
  sourcingJob               SourcingJob               @relation(fields: [sourcingJobId], references: [id], onDelete: Cascade)

  @@unique([sourcingJobId, profileUrl])
  @@index([sourcingJobId, matchScore(sort: Desc)])
  @@index([profileUrl])
  @@index([batchNumber])
  @@index([seniorityLevel])
  @@index([isOpenToWork])
}

// ==========================================
// CREDIT SYSTEM
// ==========================================

enum TransactionType {
  CREDIT
  DEBIT
  RESET
  REFUND
}

enum CreditCategory {
  SOURCING
  SCREENING
}

enum SubscriptionStatus {
  ACTIVE
  CANCELLED
  EXPIRED
  PENDING
}

model Plan {
  id               String         @id @default(cuid())
  name             String
  slug             String         @unique
  priceInRupees    Int
  sourcingCredits  Int
  screeningCredits Int
  billingCycle     String         @default("monthly")
  isActive         Boolean        @default(true)
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
  subscriptions    Subscription[]

  @@map("plans")
}

model UserCredits {
  id               String              @id @default(cuid())
  userId           String              @unique
  sourcingCredits  Int                 @default(0)
  screeningCredits Int                 @default(0)
  lastResetAt      DateTime            @default(now())
  createdAt        DateTime            @default(now())
  updatedAt        DateTime            @updatedAt
  user             User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  transactions     CreditTransaction[]

  @@map("user_credits")
}

model CreditTransaction {
  id             String         @id @default(cuid())
  userCreditsId  String
  type           TransactionType
  category       CreditCategory
  amount         Int
  balanceAfter   Int
  referenceId    String?
  referenceType  String?
  description    String?
  createdAt      DateTime       @default(now())
  userCredits    UserCredits    @relation(fields: [userCreditsId], references: [id], onDelete: Cascade)

  @@index([userCreditsId])
  @@index([createdAt])
  @@map("credit_transactions")
}

model Subscription {
  id                 String             @id @default(cuid())
  userId             String             @unique
  planId             String
  status             SubscriptionStatus @default(ACTIVE)
  currentPeriodStart DateTime           @default(now())
  currentPeriodEnd   DateTime
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt
  cancelledAt        DateTime?
  user               User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  plan               Plan               @relation(fields: [planId], references: [id])

  @@index([userId])
  @@index([status, currentPeriodEnd])
  @@map("subscriptions")
}


enum SourcingJobStatus {
  CREATED
  FORMATTING_JD
  JD_FORMATTED
  SEARCHING_PROFILES
  PROFILES_FOUND
  SCRAPING_PROFILES
  PARSING_PROFILES
  SAVING_PROFILES
  SCORING_PROFILES
  COMPLETED
  RATE_LIMITED
  FAILED
}

enum InterviewReadinessStatus {
  NOT_ASSESSED
  READY_TO_INTERVIEW
  INTERVIEW_WITH_VALIDATION
  NOT_RECOMMENDED
}

enum CandidateEnrichmentStatus {
  PENDING
  ENRICHED
  NO_EMAIL_FOUND
  SKIPPED
}
