generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id             String          @id
  email          String          @unique
  name           String?
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  sourcingJobs   SourcingJob[]
  jobs           Job[]
  userCredits    UserCredits?
  subscription   Subscription?
  emailTemplates EmailTemplate[]
  interviews     Interview[]

  @@map("users")
}

model Job {
  id                 String          @id @default(uuid())
  userId             String
  title              String
  description        String?
  jdFileUrl          String?
  requiredSkills     String[]
  experienceRequired String?
  qualifications     String[]
  status             String          @default("draft")
  totalCandidates    Int             @default(0)
  createdAt          DateTime        @default(now())
  updatedAt          DateTime        @updatedAt
  candidates         Candidate[]
  user               User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  processingLogs     ProcessingLog[]
  interviews         Interview[]

  @@index([userId])
  @@map("jobs")
}

model Candidate {
  id                   String      @id @default(uuid())
  jobId                String
  name                 String
  email                String?
  phone                String?
  resumeUrl            String
  resumeText           String?
  skills               String[]
  experience           Json?
  education            Json?
  totalExperienceYears Int?
  matchScore           Int?
  matchedSkills        String[]
  missingSkills        String[]
  fitVerdict           String?
  summary              String?
  strengths            String[]
  weaknesses           String[]
  processingStatus     String      @default("pending")
  processingError      String?
  createdAt            DateTime    @default(now())
  updatedAt            DateTime    @updatedAt
  resumePath           String
  job                  Job         @relation(fields: [jobId], references: [id], onDelete: Cascade)
  interviews           Interview[]

  @@index([jobId])
  @@index([matchScore])
  @@map("candidates")
}

model ProcessingLog {
  id               String    @id @default(uuid())
  jobId            String
  status           String
  totalResumes     Int?
  processedResumes Int       @default(0)
  failedResumes    Int       @default(0)
  errorMessage     String?
  startedAt        DateTime  @default(now())
  completedAt      DateTime?
  job              Job       @relation(fields: [jobId], references: [id], onDelete: Cascade)

  @@map("processing_logs")
}

model SourcingJob {
  id                  String              @id @default(cuid())
  userId              String
  title               String
  rawJobDescription   String
  maxCandidates       Int                 @default(50)
  searchFilters       Json?
  discoveredUrls      Json?
  status              SourcingJobStatus   @default(CREATED)
  totalProfilesFound  Int                 @default(0)
  profilesScraped     Int                 @default(0)
  profilesScored      Int                 @default(0)
  processingStartedAt DateTime?
  lastActivityAt      DateTime?
  errorMessage        String?
  retryCount          Int                 @default(0)
  failedAt            DateTime?
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt
  completedAt         DateTime?
  scrapedProfilesData Json?
  parsedProfilesData  Json?
  currentStage        String?
  profilesParsed      Int                 @default(0)
  profilesSaved       Int                 @default(0)
  rateLimitHitAt      DateTime?
  rateLimitResetAt    DateTime?
  maxRetries          Int                 @default(3)
  jobRequirements     Json?
  lastCompletedStage  String?
  enrichedUrls        Json?
  rateLimitService    String?
  usedQueryIndices    Json?
  candidates          LinkedInCandidate[]
  user                User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  interviews          Interview[]

  @@index([userId, status])
  @@index([lastActivityAt])
  @@index([status, lastActivityAt])
}

model LinkedInCandidate {
  id                        String                    @id @default(cuid())
  sourcingJobId             String
  fullName                  String
  headline                  String?
  location                  String?
  profileUrl                String
  photoUrl                  String?
  currentPosition           String?
  currentCompany            String?
  experienceYears           Int?
  skills                    Json?
  experience                Json?
  education                 Json?
  email                     String?
  phone                     String?
  hasContactInfo            Boolean                   @default(false)
  matchScore                Float                     @default(0)
  skillsScore               Float                     @default(0)
  experienceScore           Float                     @default(0)
  industryScore             Float                     @default(0)
  titleScore                Float                     @default(0)
  matchReason               String?
  isScored                  Boolean                   @default(false)
  isDuplicate               Boolean                   @default(false)
  firstSeenJobId            String?
  batchNumber               Int                       @default(0)
  rawData                   Json?
  scrapedAt                 DateTime?
  scoredAt                  DateTime?
  bonusSkills               Json?
  certifications            Json?
  connections               Int?
  currentCompanyLogo        String?
  currentJobDuration        String?
  duplicateCount            Int                       @default(0)
  followers                 Int?
  industryMatch             String?
  isOpenToWork              Boolean                   @default(false)
  isPremium                 Boolean                   @default(false)
  isVerified                Boolean                   @default(false)
  languages                 Json?
  linkedInId                String?
  matchedSkills             Json?
  missingSkills             Json?
  niceToHaveScore           Float                     @default(0)
  publicIdentifier          String?
  relevantYears             Int?
  scoringVersion            String?
  seniorityLevel            String?
  updatedAt                 DateTime                  @updatedAt
  aiAnalysisVersion         String?                   @default("v3.0")
  analysisGeneratedAt       DateTime?
  candidateSummary          String?
  criticalGaps              Json?
  experienceAnalysisSummary String?
  experienceHighlights      Json?
  experienceRelevanceScore  Float?                    @default(0)
  fullAnalysisGenerated     Boolean                   @default(false)
  gapsAndTradeoffs          Json?
  gapsOverallImpact         String?
  gapsSummary               String?
  hasSignificantGaps        Boolean                   @default(false)
  industryAlignment         String?
  interviewConfidenceScore  Float?                    @default(0)
  interviewFocusAreas       Json?
  interviewFocusSummary     String?
  interviewReadiness        InterviewReadinessStatus  @default(NOT_ASSESSED)
  interviewReadinessReason  String?
  keyStrengths              Json?
  redFlags                  Json?
  seniorityAlignment        String?
  skillGapImpact            String?
  skillsAnalysisSummary     String?
  skillsProficiency         Json?
  suggestedQuestions        Json?
  emailSource               String?
  enrichedAt                DateTime?
  enrichmentStatus          CandidateEnrichmentStatus @default(PENDING)
  scrapingStatus            String?
  sourcingJob               SourcingJob               @relation(fields: [sourcingJobId], references: [id], onDelete: Cascade)
  interviews                Interview[]

  @@unique([sourcingJobId, profileUrl])
  @@index([sourcingJobId, matchScore(sort: Desc)])
  @@index([profileUrl])
  @@index([batchNumber])
  @@index([seniorityLevel])
  @@index([isOpenToWork])
}

// ==========================================
// CREDIT SYSTEM
// ==========================================

enum TransactionType {
  CREDIT
  DEBIT
  RESET
  REFUND
}

enum CreditCategory {
  SOURCING
  SCREENING
}

enum SubscriptionStatus {
  ACTIVE
  CANCELLED
  EXPIRED
  PENDING
}

model Plan {
  id               String         @id @default(cuid())
  name             String
  slug             String         @unique
  priceInRupees    Int
  sourcingCredits  Int
  screeningCredits Int
  billingCycle     String         @default("monthly")
  isActive         Boolean        @default(true)
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
  subscriptions    Subscription[]

  @@map("plans")
}

model UserCredits {
  id               String              @id @default(cuid())
  userId           String              @unique
  sourcingCredits  Int                 @default(0)
  screeningCredits Int                 @default(0)
  lastResetAt      DateTime            @default(now())
  createdAt        DateTime            @default(now())
  updatedAt        DateTime            @updatedAt
  user             User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  transactions     CreditTransaction[]

  @@map("user_credits")
}

model CreditTransaction {
  id             String         @id @default(cuid())
  userCreditsId  String
  type           TransactionType
  category       CreditCategory
  amount         Int
  balanceAfter   Int
  referenceId    String?
  referenceType  String?
  description    String?
  createdAt      DateTime       @default(now())
  userCredits    UserCredits    @relation(fields: [userCreditsId], references: [id], onDelete: Cascade)

  @@index([userCreditsId])
  @@index([createdAt])
  @@map("credit_transactions")
}

model Subscription {
  id                 String             @id @default(cuid())
  userId             String             @unique
  planId             String
  status             SubscriptionStatus @default(ACTIVE)
  currentPeriodStart DateTime           @default(now())
  currentPeriodEnd   DateTime
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt
  cancelledAt        DateTime?
  user               User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  plan               Plan               @relation(fields: [planId], references: [id])

  @@index([userId])
  @@index([status, currentPeriodEnd])
  @@map("subscriptions")
}


enum SourcingJobStatus {
  CREATED
  FORMATTING_JD
  JD_FORMATTED
  SEARCHING_PROFILES
  PROFILES_FOUND
  SCRAPING_PROFILES
  PARSING_PROFILES
  SAVING_PROFILES
  SCORING_PROFILES
  COMPLETED
  RATE_LIMITED
  FAILED
}

enum InterviewReadinessStatus {
  NOT_ASSESSED
  READY_TO_INTERVIEW
  INTERVIEW_WITH_VALIDATION
  NOT_RECOMMENDED
}

enum CandidateEnrichmentStatus {
  PENDING
  ENRICHED
  NO_EMAIL_FOUND
  SKIPPED
}

// ==========================================
// INTERVIEW SYSTEM
// ==========================================

model EmailTemplate {
  id         String            @id @default(cuid())
  userId     String
  name       String
  type       EmailTemplateType
  subject    String
  bodyHtml   String            @db.Text
  bodyText   String?           @db.Text
  variables  Json              @default("{}")
  isDefault  Boolean           @default(false)
  isActive   Boolean           @default(true)
  createdAt  DateTime          @default(now())
  updatedAt  DateTime          @updatedAt
  user       User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  interviews Interview[]

  @@index([userId, type, isDefault])
  @@map("email_templates")
}

model Interview {
  id                    String                @id @default(cuid())
  userId                String

  // Candidate relations (one of these will be set based on source)
  candidateId           String?               // For SCREENING source
  linkedInCandidateId   String?               // For SOURCING source

  // Job relations (one of these will be set based on source)
  jobId                 String?               // For SCREENING source (links to Job)
  sourcingJobId         String?               // For SOURCING source (links to SourcingJob)

  source                InterviewSource
  linkToken             String                @unique
  interviewLink         String
  vapiAssistantId       String?
  vapiCallId            String?
  emailTemplateId       String?
  customEmailSubject    String?
  customEmailBody       String?               @db.Text
  status                InterviewStatus       @default(PENDING)
  linkSentAt            DateTime?
  linkOpenedAt          DateTime?
  linkExpiresAt         DateTime
  startedAt             DateTime?
  completedAt           DateTime?
  abandonedAt           DateTime?
  duration              Int?
  emailSent             Boolean               @default(false)
  remindersSent         Int                   @default(0)
  lastReminderAt        DateTime?
  transcript            String?               @db.Text
  rawMessages           Json?
  recordingUrl          String?
  overallScore          Int?
  technicalScore        Int?
  communicationScore    Int?
  cultureFitScore       Int?
  strengths             String[]
  concerns              String[]
  keyInsights           String?               @db.Text
  recommendation        HiringRecommendation?
  detailedAnalysis      Json?
  abandonedAtQuestion   String?
  noShowReason          String?
  createdAt             DateTime              @default(now())
  updatedAt             DateTime              @updatedAt

  // Relations
  user                  User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  candidate             Candidate?            @relation(fields: [candidateId], references: [id], onDelete: Cascade)
  linkedInCandidate     LinkedInCandidate?    @relation(fields: [linkedInCandidateId], references: [id], onDelete: Cascade)
  job                   Job?                  @relation(fields: [jobId], references: [id], onDelete: Cascade)
  sourcingJob           SourcingJob?          @relation(fields: [sourcingJobId], references: [id], onDelete: Cascade)
  emailTemplate         EmailTemplate?        @relation(fields: [emailTemplateId], references: [id], onDelete: SetNull)

  @@index([userId, status])
  @@index([linkToken])
  @@index([vapiCallId])
  @@index([candidateId])
  @@index([linkedInCandidateId])
  @@index([jobId])
  @@index([sourcingJobId])
  @@map("interviews")
}

enum EmailTemplateType {
  INTERVIEW_INVITATION
  REMINDER_24H
  REMINDER_6H
  FOLLOW_UP
  CUSTOM
}

enum InterviewSource {
  SCREENING
  SOURCING
}

enum InterviewStatus {
  PENDING
  LINK_SENT
  LINK_OPENED
  IN_PROGRESS
  COMPLETED
  ABANDONED
  EXPIRED
  NO_SHOW
  CANCELLED
}

enum HiringRecommendation {
  STRONG_YES
  YES
  MAYBE
  NO
}
